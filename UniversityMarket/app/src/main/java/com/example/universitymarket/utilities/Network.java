package com.example.universitymarket.utilities;

/**
 * <b>
 * ANY MODIFICATIONS ABOVE THESE JAVADOC BOUNDS WILL BE OVERWRITTEN ON BUILD
 * <div>
 * DO NOT REMOVE THIS
 * </b><p>
 * Autogenerated on: Mar 6, 2024, 4:49:08 AM
 */

import android.app.Activity;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.example.universitymarket.R;
import com.example.universitymarket.globals.Policy;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.TaskCompletionSource;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.Filter;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;
import org.json.JSONException;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeoutException;

public abstract class Network {

    @NonNull
    @SafeVarargs
    private static Task<HashMap<String, Object>> setDoc(@NonNull Activity cur_act, @NonNull String collID, @NonNull String docID, boolean clear, HashMap<String, Object>... obj) {
        final FirebaseFirestore db = FirebaseFirestore.getInstance();
        final TaskCompletionSource<HashMap<String, Object>> source = new TaskCompletionSource<>();
        HashMap<String, Object> pojoObj = new HashMap<>();
        HashMap<String, Object> pojo;
        String illCollID = "Must be 'users', 'posts', 'transactions', or 'test'";
        String illNumObj = "Must contain either zero or one argument";
        String illReqObj = "Cached data for '" + docID + "' not found";
        String illNullData = "POJO data could not be found";

        if(obj.length > 1) {
            if(!source.getTask().isComplete())
                source.setException(new IllegalArgumentException(illNumObj));
            return source.getTask();
        } else if(obj.length == 1) {
            HashMap<String, Object> buffer = obj[0];
            Data.mergeHash(pojoObj, buffer);
        }

        DocumentReference reference = db.collection(collID).document(docID);

        switch(collID) {
            case "users":
            case "test":
            case "transactions":
            case "posts":
                if(obj.length == 0 && !clear) {
                    HashMap<String, Object> buffer = Data.getCachedToPOJO(cur_act, docID);
                    if(buffer != null) {
                        pojo = buffer;
                    } else {
                        if (!source.getTask().isComplete())
                            source.setException(new IllegalArgumentException(illReqObj));
                        return source.getTask();
                    }
                } else {
                    pojo = pojoObj;
                }
                break;
            default:
                if(!source.getTask().isComplete())
                    source.setException(new IllegalArgumentException(illCollID));
                return source.getTask();
        }

        if(clear || pojo.size() == 0) {
            if (!source.getTask().isComplete()) {
                if (clear) {
                    reference.delete();
                    source.setResult(new HashMap<>());
                } else {
                    source.setException(new NullPointerException(illNullData));
                }
            }
            return source.getTask();
        }

        reference.set(pojo)
                .addOnSuccessListener(task -> {
                    if(!source.getTask().isComplete())
                        source.setResult(pojo);
                })
                .addOnFailureListener(e -> {
                    if(!source.getTask().isComplete())
                        source.setException(e);
                });
        return source.getTask();
    }

    @NonNull
    private static Task<HashMap<String, Object>> getDoc(@NonNull Activity cur_act, @NonNull String collID, @NonNull String docID) {
        final FirebaseFirestore db = FirebaseFirestore.getInstance();
        final TaskCompletionSource<HashMap<String, Object>> source = new TaskCompletionSource<>();
        String illCollID = "Must be 'users', 'posts', 'transactions', or 'test'";
        String illNullData = "Collection '" + collID + "' or document '" + docID + "' does not exist";
        String illFormat = "'" + docID + "' from '" + collID + "' is not in skeleton format!";
        new Handler(Looper.getMainLooper()).postDelayed(() -> {
            if (!source.getTask().isComplete())
                source.setException(new TimeoutException());
        }, Policy.max_seconds_before_timeout * 1000);

        int resID;
        HashMap<String, Object> pojo;
        Task<DocumentSnapshot> reference = db.collection(collID).document(docID).get();

        switch(collID) {
            case "users":
                resID = R.raw.user_skeleton_cached;
                break;
            case "posts":
                resID = R.raw.post_skeleton;
                break;
            case "transactions":
                resID = R.raw.transaction_skeleton;
                break;
            case "test":
                resID = R.raw.test_skeleton;
                break;
            default:
                if(!source.getTask().isComplete())
                    source.setException(new IllegalArgumentException(illCollID));
                return source.getTask();
        }

        pojo = Data.resToPOJO(cur_act, resID);

        reference
                .addOnSuccessListener(task -> {
                    if(!source.getTask().isComplete() && !reference.getResult().exists()) {
                        source.setException(new NullPointerException(illNullData));
                        return;
                    }

                    Map<String, Object> rawdata = task.getData();
                    List<Object> members = new ArrayList<>();
                    for(String s : pojo.keySet()) {
                        if(s.equals("access_token"))
                            continue;
                        members.add(rawdata != null ? rawdata.get(s) : null);
                    }

                    if(!source.getTask().isComplete() && isAnyObjectNull(members)) {
                        source.setException(new JSONException(illFormat));
                        return;
                    }

                    Data.mergeHash(pojo, rawdata);
                    source.setResult((HashMap<String, Object>) rawdata);
                })
                .addOnFailureListener(e -> {
                    if(!source.getTask().isComplete())
                        source.setException(e);
                });

        return source.getTask();
    }

    @NonNull
    private static Task<List<HashMap<String, Object>>> getColl(@NonNull Activity cur_act, @NonNull String collID, @Nullable Filter filter, int pageNo) {
        final FirebaseFirestore db = FirebaseFirestore.getInstance();
        final TaskCompletionSource<List<HashMap<String, Object>>> source = new TaskCompletionSource<>();
        String illCollID = "Must be 'users', 'posts', 'transactions', or 'test'";
        String illNullData = "Collection '" + collID + "' does not exist";
        new Handler(Looper.getMainLooper()).postDelayed(() -> {
            if (!source.getTask().isComplete())
                source.setException(new TimeoutException());
        }, Policy.max_seconds_before_timeout * 1000);

        Query query = db.collection(collID);
        query = filter != null ? query.where(filter) : query;
        if(pageNo >= 0) {
            query.startAt(Policy.max_docs_loaded * pageNo);
            query.limit(Policy.max_docs_loaded);
        }
        Task<QuerySnapshot> reference = query.get();

        switch(collID) {
            case "users":
            case "posts":
            case "transactions":
            case "test":
                break;
            default:
                if(!source.getTask().isComplete())
                    source.setException(new IllegalArgumentException(illCollID));
                return source.getTask();
        }

        reference
                .addOnSuccessListener(coll -> {
                    if(!source.getTask().isComplete() && reference.getResult().isEmpty()) {
                        source.setException(new NullPointerException(illNullData));
                        return;
                    }
                    List<HashMap<String, Object>> list = new ArrayList<>();
                    List<DocumentSnapshot> docs = coll.getDocuments();

                    for(int i = 0; i < docs.size(); i++) {
                        DocumentSnapshot thisDoc = docs.get(i);
                        Task<HashMap<String, Object>> echo = getDoc(cur_act, collID, thisDoc.getId());
                        echo.addOnFailureListener(err ->
                                Log.e("getColl", thisDoc.getId() + " doc is invalid: " + err)
                        );
                        if (i == docs.size() - 1) {
                            echo.addOnSuccessListener(task -> {
                                list.add(task);
                                if(!source.getTask().isComplete())
                                    source.setResult(list);
                            });
                        } else {
                            echo.addOnSuccessListener(list::add);
                        }
                    }
                })
                .addOnFailureListener(e -> {
                    if(!source.getTask().isComplete())
                        source.setException(e);
                });

        return source.getTask();
    }

    public static boolean isAnyObjectNull(Object... objects) {
        for (Object o : objects) { return o == null; }
        return false;
    }

/**
 * <b>
 * ANY MODIFICATIONS BELOW THESE JAVADOC BOUNDS WILL BE OVERWRITTEN ON BUILD
 * <div>
 * DO NOT REMOVE THIS
 * </b><p>
 * Autogenerated on: Mar 6, 2024, 4:49:08 AM
 */

}