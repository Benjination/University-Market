import groovy.json.*
import java.time.*
import java.time.format.*

static Object typeString(String line) {
    Object field
    if(line.matches("([0-9]+\\.[0-9]+)")) {
        if(line.length() <= 20)
            field = Float.parseFloat(line)
        else if(line.length() <= 40)
            field = Double.parseDouble(line)
        else
            field = new BigDecimal(line)
    } else if(line.matches("[0-9]+")) {
        BigInteger val = new BigInteger(line)
        if(val <= Integer.MAX_VALUE)
            field = Integer.parseInt(line)
        else if(val <= Long.MAX_VALUE)
            field = Long.parseLong(line)
        else
            field = val
    } else {
        field = line
    }
    return field
}

static String checkGeneric(def type, def parent, def map, int index) {
    if(index == -1)
        return "super"
    def arr = ((String) parent.getClass()).split("\\.")
    String ptype = arr[arr.length - 1], pname = null
    int idx = -1, pidx = -1
    def cmap = map.get(index)

    for(int i = 0; i < cmap.size(); i++) {
        if (!cmap.get(i).toString().contains(parent.toString()))
            continue

        for(int z = 0; z < cmap.size(); z++) {
            Object elem = cmap.get(i).get(z)
            if (elem == ptype + "<Object>")
                return
            if (elem.toString().contains(ptype)) {
                ptype = elem
                pidx = i
                idx = z
                if(z == 1)
                    pname = cmap.get(i).get(0)
                break
            }
        }
    }
    if(idx < 0 || pidx < 0)
        return

    def pmap = cmap.get(pidx)
    def temp = ptype.split("(>)+[^,]*")[0].split(".*[^a-zA-Z]+")
    ptype = ptype.split("<")[0]
    if(temp.length > 1) {
        if (temp[1] != type) {
            if (ptype.contains("Map"))
                pmap.set(idx, ptype + "<String, Object>")
            else
                pmap.set(idx, ptype + "<Object>")
        }
    } else {
        if(ptype.contains("Map"))
            pmap.set(idx, ptype + "<String, " + type + ">")
        else
            pmap.set(idx, ptype + "<" + type + ">")
    }
    return pname
}

static void elemAdd(Object first, Object second, Object third, def list, def map, def index) {
    list = new ArrayList<>()
    String type = "", name = null
    if(first instanceof String) {
        list.add(first)
        name = first
    }
    if(third instanceof String | third instanceof Number) {
        third = typeString(third.toString())
    } else if(third.size == 0) {
        if(third instanceof Map)
            type = "<String, Object>"
        else
            type = "<Object>"
    }
    String[] arr = ((String) third.getClass()).split("\\.")
    String buffer = type
    type = arr[arr.length - 1].concat(buffer)
    Object parent = list.size() != 0 ? second : first
    String from = checkGeneric(type, parent, map, index - 1)
    list.add(type)

    if(second instanceof Number)
        list.add(second)
    list.add(third)
    if(from != null)
        list.add(from)
    map.get(index).add(list)
}

static void mapAdd(Object data, ArrayList<Object> map, int index) {
    List<Object> list = new ArrayList<>()
    if(index + 1 > map.size()) {
        map.add(list)
    }
    if(data instanceof Map) {
        for(key in data.keySet()) {
            elemAdd(key, data, data.get(key), list, map, index)
        }
    } else if(data instanceof List) {
        for(int i = 0; i < ((ArrayList) data).size(); i++) {
            elemAdd(data, i + "", data.get(i), list, map, index)
        }
    }
}

void expand(def val, def map, def depth) {
    mapAdd(val, map, depth)
    for(obj in val) {
        if(obj instanceof Map) {
            HashMap<String, Object> json = new JsonSlurperClassic().parseText(new JsonBuilder(obj).toString())
            crawl(json, map, depth + 1)
        }
        if(obj instanceof List) {
            expand(obj, map, depth + 1)
        }
    }
}

void crawl(def json, def map, def depth) {
    mapAdd(json, map, depth)
    for(val in json.values()) {
        if(val instanceof Map) {
            String temp = new JsonBuilder(val).toString()
            json = new JsonSlurperClassic().parseText(temp)
            crawl(json, map, depth + 1)
        }
        if(val instanceof List) {
            expand(val, map, depth + 1)
        }
    }
}

String generate(def map, def class_name, def file) {
    String tab = "    "

    def temp = file.getPath().split("/")
    String filepath = ""
    for(int i = 4; i > 1; i--)
        filepath = filepath.concat(temp[temp.length - i] + "/")
    String comments = \
            "/**\n * <b>\n * ANY MODIFICATIONS WILL BE OVERWRITTEN ON BUILD \n" +
            " * </b><p>\n * Autogenerated on: " +
            DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                    .format(LocalDateTime.now()) + "\n" +
            " * <div>\n * File based on '" + file.name + "'" +
            " located at <a href=\"file://" + file.getPath().split(file.name)[0] + "\">" + filepath + "</a>\n" +
            "*/\n"
    String packag = "package com.example.universitymarket.objects;\n"
    String imports = \
            "\nimport com.example.universitymarket.utilities.Data;\n" +
            "import java.util.HashMap;\n" +
            "import java.util.ArrayList;\n\n"
    String declarations = ""
    String constructor = \
            "\n" + tab + "public " + class_name + "(HashMap<String, Object> rawdata) {\n"
    String methods = ""

    println(
            "__________________________________________________\n" +
            "\tGenerating class from " + file.name + "\n" +
            "=================================================="
    )
    for(int pass = 0; pass < 3; pass++) {
        for (int i = 0; i < map.size(); i++) {
            for (int z = 0; z < map.get(i).size(); z++) {
                def cmap = map.get(i).get(z)
                int csize = cmap.size()

                if (csize < 4)
                    continue

                temp = ((String) cmap.get(1).toString()).split("^[^<]+")
                String name = cmap.get(0), type = cmap.get(1), data = cmap.get(2), prov = cmap.get(3)
                String generic = temp.size() > 1 ? temp[1] : "", mname = ""
                temp = name.split("[^a-zA-Z0-9]")
                for (ss in temp) {
                    int size = ss.size()
                    if (size > 0)
                        mname = mname.concat(ss.charAt(0).toUpperCase().toString())
                    if (size > 1)
                        mname = mname.concat(ss.substring(1))
                }

                switch(pass) {
                    case 0:
                        println(cmap)
                        if (i == 0) {
                            constructor = constructor.concat(
                                    tab + tab + "super.put(\"" + name + "\", rawdata.get(\"" + name + "\"));\n"
                            )
                        }
                        declarations = declarations.concat(
                                tab + "private " + type + " " + name + " = null;\n"
                        )
                        methods = methods.concat(
                                "\n\n" + tab + "public " + type + " get" +
                                        mname + "() { return " + name + "; }"
                        )
                        break
                    case 1:
                        constructor = constructor.concat(
                                tab + tab + name + " = (" + type + ") " + prov + ".get(\"" + name + "\");\n"
                        )

                        if (generic == "<HashMap>") {
                            declarations = declarations.concat(
                                    tab + "private HashMap<String, Object> " + name + "Map = new HashMap<>();\n"
                            )
                            methods = methods.concat(
                                    "\n\n" + tab + "public HashMap<String, Object> get" +
                                            mname + "Map() { return " + name + "Map; }"
                            )
                        }
                        break
                    case 2:
                        if (prov == "super") {
                            methods = methods.concat(
                                    "\n\n" + tab + "public void set" +
                                            mname + "(" + type + " " + name + ") { super.put(\"" +
                                            name + "\", " + name + "); }"
                            )
                        }
                        if (generic == "<HashMap>") {
                            constructor = constructor.concat(
                                    "\n" + tab + tab + "for(Object o : " + name + ") {\n" +
                                            tab + tab + tab + "Data.mergeHash(" + name + "Map, (HashMap<String, Object>) o);\n" +
                                            tab + tab + "}\n"
                            )
                        }
                }
            }
            if(pass == 0)
                println()
        }
    }
    constructor = constructor.concat(tab + "}")
    methods = methods.concat("\n\n" + tab + "public HashMap<String, Object> getSuper() { return this; }")

    String body = declarations + constructor + methods
    String definition = \
            "public class " + class_name + " extends HashMap<String, Object> {\n" +
            body + "\n}"

    return packag + imports + comments + definition
}

task generateObjectFiles {
    File[] skeletons = file("${project.projectDir}/src/main/res/raw").listFiles()
    Map<String, File> skeleton_map = new HashMap<>()
    File object_path = file("${project.projectDir}/src/main/java/com/example/universitymarket/objects")
    for (s in skeletons) {
        String temp = s.getName().split("(_skeleton\\.json)")[0]
        StringBuilder name = new StringBuilder()
                .append(temp.charAt(0).toUpperCase())
                .append(temp.substring(1, temp.length()))
                .append(".java")
        skeleton_map.put(name.toString(), s)
    }
    for (sn in skeleton_map.keySet()) {
        String name = sn.split("\\.")[0]
        List<Object> map = new ArrayList<>()
        HashMap<String, Object> json = new JsonSlurperClassic().parseText(skeleton_map.get(sn).text)
        crawl(json, map, 0)

        new File(object_path, sn).write(generate(map, name, skeleton_map.get(sn)))
    }
}
